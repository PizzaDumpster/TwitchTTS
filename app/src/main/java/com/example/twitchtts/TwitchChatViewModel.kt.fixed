package com.example.twitchtts

import android.content.Context
import android.content.Intent
import android.media.AudioAttributes
import android.media.AudioFocusRequest
import android.media.AudioManager
import android.os.Build
import android.os.Bundle
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.speech.tts.Voice as AndroidVoice
import android.util.Log
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.util.Locale
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger

class TwitchChatViewModel : ViewModel() {
    
    private val _chatMessages = mutableStateListOf<ChatMessage>()
    val chatMessages: List<ChatMessage> = _chatMessages
    
    val channelName = mutableStateOf("")
    val isConnected = mutableStateOf(false)
    val isTtsEnabled = mutableStateOf(true)
    
    // TTS queue size management
    val maxTtsQueueSize = mutableStateOf(5) // Maximum number of messages in queue
    val currentQueueSize = mutableStateOf(0) // Current number of messages waiting
    val speechRate = mutableStateOf(1.0f) // Speech rate: 0.5 (slower) to 2.0 (faster)
    
    // Voice selection
    private val _availableVoices = mutableStateListOf<Voice>()
    val availableVoices: List<Voice> = _availableVoices
    val selectedVoice = mutableStateOf<Voice?>(null)
    
    // Maximum chat history size - can be adjusted
    val maxChatHistorySize = mutableStateOf(100)
    
    // Memory management - track processed messages to detect potential leaks
    private val messageCount = AtomicInteger(0)
    private var lastMemoryCheckTime = System.currentTimeMillis()
    private var memoryCheckJob: Job? = null
    
    private var textToSpeech: TextToSpeech? = null
    private val ttsQueue = ConcurrentLinkedQueue<String>()
    private var isSpeaking = false
    
    // Audio focus handling
    private var audioManager: AudioManager? = null
    private var audioFocusRequest: AudioFocusRequest? = null
    private val audioAttributes by lazy {
        AudioAttributes.Builder()
            .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
            .setUsage(AudioAttributes.USAGE_MEDIA)
            .build()
    }
    
    private val chatService = TwitchChatService()
    private var chatJob: Job? = null
    
    init {
        // Start periodic memory check
        startMemoryCheck()
    }
    
    private fun startMemoryCheck() {
        memoryCheckJob = viewModelScope.launch(Dispatchers.Default) {
            while (true) {
                delay(60000) // Check every minute
                performMemoryMaintenance()
            }
        }
    }
    
    private fun performMemoryMaintenance() {
        // Log memory stats
        val runtime = Runtime.getRuntime()
        val usedMemoryMB = (runtime.totalMemory() - runtime.freeMemory()) / 1048576L
        val maxMemoryMB = runtime.maxMemory() / 1048576L
        val memoryUsagePercent = (usedMemoryMB.toFloat() / maxMemoryMB) * 100
        
        Log.d("TwitchTTS", "Memory: ${usedMemoryMB}MB / ${maxMemoryMB}MB (${memoryUsagePercent.toInt()}%)")
        Log.d("TwitchTTS", "Messages processed: ${messageCount.get()}, Chat history size: ${_chatMessages.size}")
        
        // If memory usage is high (over 70%), trim chat history more aggressively
        if (memoryUsagePercent > 70 && _chatMessages.size > 50) {
            val toRemove = _chatMessages.size / 2
            repeat(toRemove) {
                if (_chatMessages.isNotEmpty()) {
                    _chatMessages.removeAt(_chatMessages.lastIndex)
                }
            }
            Log.d("TwitchTTS", "Memory pressure detected: Reduced chat history by $toRemove messages")
        }
        
        // Request garbage collection (this is just a suggestion to the system)
        System.gc()
    }
    
    // Initialize TextToSpeech
    fun initTts(context: Context) {
        // Clean up any existing TTS instance first to prevent memory leaks
        cleanupTts()
        
        // Get AudioManager
        audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
        
        try {
            // Make sure we're not already speaking before creating a new instance
            isSpeaking = false
            
            // Clear any leftover queue
            ttsQueue.clear()
            updateQueueSize()
            
            textToSpeech = TextToSpeech(context.applicationContext) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    val result = textToSpeech?.setLanguage(Locale.US)
                    if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                        Log.e("TTS", "Language not supported")
                    } else {
                        setupTtsCallbacks()
                        
                        // Load available voices
                        loadAvailableVoices()
                        
                        // Set initial speech rate
                        textToSpeech?.setSpeechRate(speechRate.value)
                        
                        // Set stream type and buffer size to handle audio better
                        textToSpeech?.setOnUtteranceCompletedListener { _ ->
                            // Additional safeguard for older Android versions
                            viewModelScope.launch(Dispatchers.Main) {
                                isSpeaking = false
                                abandonAudioFocus()
                                processNextTtsItem()
                            }
                        }
                        
                        // Use modern audio attributes instead of stream type for API 21+
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                            textToSpeech?.setAudioAttributes(audioAttributes)
                        } else {
                            @Suppress("DEPRECATION")
                            textToSpeech?.setEngineByPackageName("com.google.android.tts")
                        }
                        
                        // If we're on an emulator, use a smaller buffer size
                        val isEmulator = Build.FINGERPRINT.startsWith("generic") || 
                                          Build.FINGERPRINT.startsWith("unknown") ||
                                          Build.MODEL.contains("google_sdk") || 
                                          Build.MODEL.contains("Emulator")
                        
                        if (isEmulator && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                            val bundle = Bundle()
                            bundle.putInt(TextToSpeech.Engine.KEY_PARAM_STREAM, AudioManager.STREAM_MUSIC)
                            bundle.putInt(TextToSpeech.Engine.KEY_FEATURE_NETWORK_TIMEOUT_MS, 3000)
                            textToSpeech?.setLanguage(Locale.US)
                            Log.d("TTS", "Using emulator-specific TTS settings")
                        }
                    }
                } else {
                    Log.e("TTS", "TTS Initialization failed with status: $status")
                }
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error initializing TextToSpeech", e)
        }
    }
    
    /**
     * Load available TTS voices
     */
    private fun loadAvailableVoices() {
        _availableVoices.clear()
        
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                // Modern implementation with Voice objects (API 21+)
                textToSpeech?.let { tts ->
                    val voices = tts.voices
                    if (voices != null && voices.isNotEmpty()) {
                        // Create voice objects from Android voices
                        val mappedVoices = voices
                            .filter { it.locale == Locale.US } // Only use English (US) voices
                            .mapNotNull { Voice.fromAndroidVoice(it) }
                            .sortedByDescending { it.quality } // Higher quality voices first
                        
                        viewModelScope.launch(Dispatchers.Main) {
                            _availableVoices.addAll(mappedVoices)
                            
                            // Set the default voice if we found any
                            if (_availableVoices.isNotEmpty() && selectedVoice.value == null) {
                                selectedVoice.value = _availableVoices.first()
                                setVoice(_availableVoices.first())
                            }
                        }
                        
                        Log.d("TTS", "Loaded ${mappedVoices.size} voices")
                    } else {
                        loadFallbackVoice()
                    }
                }
            } else {
                // Fallback for older Android versions
                loadFallbackVoice()
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error loading voices", e)
            loadFallbackVoice()
        }
    }
    
    /**
     * Load a fallback default voice when no voices are available
     */
    private fun loadFallbackVoice() {
        val defaultVoice = Voice.createDefaultVoice(Locale.US)
        viewModelScope.launch(Dispatchers.Main) {
            _availableVoices.add(defaultVoice)
            selectedVoice.value = defaultVoice
        }
        Log.d("TTS", "Using fallback voice")
    }
    
    // Separate cleanup method for TTS resources
    private fun cleanupTts() {
        try {
            textToSpeech?.let { tts ->
                tts.stop()
                tts.shutdown()
                textToSpeech = null
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error cleaning up TTS", e)
        }
    }
    
    private fun setupTtsCallbacks() {
        try {
            textToSpeech?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                override fun onStart(utteranceId: String?) {
                    viewModelScope.launch(Dispatchers.Main) {
                        Log.d("TTS", "Started utterance: $utteranceId")
                        requestAudioFocus()
                    }
                }
                
                override fun onDone(utteranceId: String?) {
                    viewModelScope.launch(Dispatchers.Main) {
                        Log.d("TTS", "Completed utterance: $utteranceId")
                        
                        // Check if this was a test utterance
                        if (utteranceId != null && utteranceId.startsWith("test_")) {
                            Log.d("TTS", "Test utterance complete")
                            isSpeaking = false
                            updateQueueSize()
                            
                            // Don't process next item immediately after a test utterance
                            // The speakTestPhrase method will handle restoring the queue
                            return@launch
                        }
                        
                        // For regular utterances, check if there are more items in the queue
                        if (ttsQueue.isNotEmpty()) {
                            // If there are more messages to process, wait for a small delay to avoid overlapping
                            delay(100)
                            isSpeaking = false
                            processNextTtsItem()
                        } else {
                            // No more messages, release audio focus
                            isSpeaking = false
                            abandonAudioFocus()
                        }
                        
                        updateQueueSize()
                    }
                }
                
                @Deprecated("Deprecated in Java")
                override fun onError(utteranceId: String?) {
                    viewModelScope.launch(Dispatchers.Main) {
                        Log.e("TTS", "TTS error with utterance ID: $utteranceId")
                        
                        // Check if this was a test utterance
                        if (utteranceId != null && utteranceId.startsWith("test_")) {
                            Log.d("TTS", "Test utterance error")
                            isSpeaking = false
                            updateQueueSize()
                            return@launch
                        }
                        
                        // Set speaking to false so we can continue with the next message
                        isSpeaking = false
                        abandonAudioFocus()
                        updateQueueSize()
                        
                        // Wait a moment before trying the next message
                        delay(300)
                        processNextTtsItem()
                    }
                }
                
                // For older Android versions
                @Suppress("DEPRECATION")
                override fun onError(utteranceId: String?, errorCode: Int) {
                    viewModelScope.launch(Dispatchers.Main) {
                        Log.e("TTS", "TTS error with utterance ID: $utteranceId, error code: $errorCode")
                        
                        // Check if this was a test utterance
                        if (utteranceId != null && utteranceId.startsWith("test_")) {
                            Log.d("TTS", "Test utterance error with code: $errorCode")
                            isSpeaking = false
                            updateQueueSize()
                            return@launch
                        }
                        
                        // Set speaking to false so we can continue with the next message
                        isSpeaking = false
                        abandonAudioFocus()
                        updateQueueSize()
                        
                        // Wait a moment before trying the next message
                        delay(300)
                        processNextTtsItem()
                    }
                }
            })
        } catch (e: Exception) {
            Log.e("TTS", "Error setting up TTS callbacks", e)
        }
    }
    
    private val audioFocusChangeListener = AudioManager.OnAudioFocusChangeListener { focusChange ->
        when (focusChange) {
            AudioManager.AUDIOFOCUS_LOSS -> {
                // Permanent loss of audio focus
                textToSpeech?.stop()
                isSpeaking = false
            }
            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {
                // Temporary loss of audio focus
                textToSpeech?.stop()
                isSpeaking = false
            }
            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {
                // Loss of audio focus for a short time, but we can duck (play at lower volume)
                textToSpeech?.setSpeechRate(speechRate.value * 0.8f)
            }
            AudioManager.AUDIOFOCUS_GAIN -> {
                // Your app has been granted audio focus
                textToSpeech?.setSpeechRate(speechRate.value)
            }
        }
    }
    
    private fun requestAudioFocus() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                // Use modern AudioFocusRequest for Android O and above
                audioFocusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)
                    .setAudioAttributes(audioAttributes)
                    .setWillPauseWhenDucked(false)
                    .setAcceptsDelayedFocusGain(true)
                    .setOnAudioFocusChangeListener(audioFocusChangeListener)
                    .build()
                
                audioManager?.requestAudioFocus(audioFocusRequest!!)
            } else {
                @Suppress("DEPRECATION")
                audioManager?.requestAudioFocus(
                    audioFocusChangeListener,
                    AudioManager.STREAM_MUSIC,
                    AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK
                )
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error requesting audio focus", e)
        }
    }
    
    /**
     * Request audio focus and wait for the result
     * @return AudioManager.AUDIOFOCUS_REQUEST_GRANTED or AudioManager.AUDIOFOCUS_REQUEST_FAILED
     */
    private fun requestAudioFocusAndWait(): Int {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                // Use modern AudioFocusRequest for Android O and above
                if (audioFocusRequest == null) {
                    audioFocusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)
                        .setAudioAttributes(audioAttributes)
                        .setWillPauseWhenDucked(false)
                        .setAcceptsDelayedFocusGain(true)
                        .setOnAudioFocusChangeListener(audioFocusChangeListener)
                        .build()
                }
                
                return audioManager?.requestAudioFocus(audioFocusRequest!!) ?: AudioManager.AUDIOFOCUS_REQUEST_FAILED
            } else {
                @Suppress("DEPRECATION")
                return audioManager?.requestAudioFocus(
                    audioFocusChangeListener,
                    AudioManager.STREAM_MUSIC,
                    AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK
                ) ?: AudioManager.AUDIOFOCUS_REQUEST_FAILED
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error requesting audio focus", e)
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED
        }
    }
    
    private fun abandonAudioFocus() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                audioFocusRequest?.let { audioManager?.abandonAudioFocusRequest(it) }
            } else {
                @Suppress("DEPRECATION")
                audioManager?.abandonAudioFocus(audioFocusChangeListener)
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error abandoning audio focus", e)
        }
    }
    
    private fun processNextTtsItem() {
        // Double-check that TTS engine is initialized and ready
        if (textToSpeech == null) {
            Log.e("TTS", "TTS engine is null, can't process item")
            return
        }

        if (ttsQueue.isNotEmpty() && !isSpeaking && isTtsEnabled.value && textToSpeech != null) {
            val nextText = ttsQueue.poll()
            updateQueueSize()
            nextText?.let { text ->
                try {
                    val utteranceId = UUID.randomUUID().toString()
                    
                    // Request audio focus before speaking
                    val audioFocusResult = requestAudioFocusAndWait()
                    if (audioFocusResult == AudioManager.AUDIOFOCUS_REQUEST_FAILED) {
                        Log.w("TTS", "Failed to get audio focus, retrying later")
                        // Put the text back in the queue and try again later
                        ttsQueue.add(text)
                        updateQueueSize()
                        viewModelScope.launch {
                            delay(1000)
                            processNextTtsItem()
                        }
                        return
                    }
                    
                    // Set speaking state to true before we start speaking
                    isSpeaking = true
                    
                    // Handle different API levels for speak method
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                        val bundle = Bundle()
                        bundle.putString(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId)
                        // Use QUEUE_ADD to ensure messages wait for each other instead of QUEUE_FLUSH which would interrupt
                        val result = textToSpeech?.speak(text, TextToSpeech.QUEUE_ADD, bundle, utteranceId)
                        if (result == TextToSpeech.ERROR) {
                            Log.e("TTS", "TTS speak error")
                            resetSpeakingState()
                        }
                    } else {
                        @Suppress("DEPRECATION")
                        val params = HashMap<String, String>()
                        params[TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID] = utteranceId
                        val result = textToSpeech?.speak(text, TextToSpeech.QUEUE_ADD, params)
                        if (result == TextToSpeech.ERROR) {
                            Log.e("TTS", "TTS speak error")
                            resetSpeakingState()
                        }
                    }
                    
                    Log.d("TTS", "Started speaking: $utteranceId")
                    
                } catch (e: Exception) {
                    Log.e("TTS", "Error processing TTS item", e)
                    resetSpeakingState()
                }
            }
        }
    }
    
    private fun resetSpeakingState() {
        // Reset speaking state in case of error
        isSpeaking = false
        abandonAudioFocus()
        
        // Try next item after a short delay
        viewModelScope.launch {
            delay(500)
            processNextTtsItem()
        }
    }
    
    private fun updateQueueSize() {
        currentQueueSize.value = ttsQueue.size
    }
    
    // Set speech rate
    fun setSpeechRate(rate: Float) {
        if (rate in 0.5f..2.0f) {
            speechRate.value = rate
            textToSpeech?.setSpeechRate(rate)
        }
    }
    
    /**
     * Set the TTS voice
     */
    fun setVoice(voice: Voice) {
        try {
            Log.d("TTS", "Changing voice to: ${voice.name}")
            
            // Store current state before voice change
            val currentTtsEnabled = isTtsEnabled.value
            val wasSpeaking = isSpeaking
            val queueContents = ArrayList(ttsQueue) // Make a copy of the queue
            
            // Temporarily disable TTS to prevent new messages from being added during voice change
            isTtsEnabled.value = false
            
            // Stop any current speech and clear queue
            textToSpeech?.stop()
            isSpeaking = false
            ttsQueue.clear()
            updateQueueSize()
            
            // Reset audio focus
            abandonAudioFocus()
            
            // Set the selected voice
            selectedVoice.value = voice
            
            // Small delay to ensure the TTS engine is ready for the voice change
            viewModelScope.launch {
                delay(100)
                
                // Apply the new voice
                try {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                        // Set voice directly if we have the Android Voice object
                        voice.androidVoice?.let { androidVoice ->
                            val result = textToSpeech?.setVoice(androidVoice)
                            if (result == TextToSpeech.ERROR) {
                                Log.e("TTS", "Failed to set voice: ${voice.name}")
                                
                                // Try fallback to locale
                                textToSpeech?.setLanguage(voice.locale)
                            } else {
                                Log.d("TTS", "Voice set to: ${voice.name}")
                            }
                        } ?: run {
                            // If we don't have the Android Voice object, try setting by locale
                            Log.d("TTS", "No Android Voice object, setting by locale: ${voice.locale}")
                            textToSpeech?.setLanguage(voice.locale)
                        }
                    } else {
                        // For older versions, try to set the language that matches the voice
                        textToSpeech?.setLanguage(voice.locale)
                    }
                    
                    delay(250) // Give the TTS engine more time to apply the voice change
                    
                    // Restore the queue if we were active before
                    if (wasSpeaking || queueContents.isNotEmpty()) {
                        // Add back the queue contents
                        if (queueContents.isNotEmpty()) {
                            ttsQueue.addAll(queueContents)
                            updateQueueSize()
                            Log.d("TTS", "Restored ${queueContents.size} messages to queue")
                        }
                        
                        // Restore TTS enabled state
                        isTtsEnabled.value = currentTtsEnabled
                        
                        // Resume processing if needed
                        if (currentTtsEnabled && !isSpeaking && ttsQueue.isNotEmpty()) {
                            delay(200) // Longer delay for stability
                            processNextTtsItem()
                        }
                    } else {
                        // Just restore the TTS enabled state
                        isTtsEnabled.value = currentTtsEnabled
                    }
                } catch (e: Exception) {
                    Log.e("TTS", "Error applying voice change", e)
                    // Restore TTS state even if there was an error
                    isTtsEnabled.value = currentTtsEnabled
                    
                    // Make sure we restore queue contents even if voice change failed
                    if (queueContents.isNotEmpty()) {
                        ttsQueue.addAll(queueContents)
                        updateQueueSize()
                        Log.d("TTS", "Restored queue after voice change error")
                        
                        if (currentTtsEnabled && !isSpeaking) {
                            delay(200)
                            processNextTtsItem()
                        }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error setting voice", e)
        }
    }
    
    /**
     * Speak a test phrase with the current voice
     */
    fun speakTestPhrase() {
        viewModelScope.launch {
            try {
                if (textToSpeech == null) {
                    Log.e("TTS", "Cannot speak test phrase: TTS engine is null")
                    return@launch
                }
                
                val testPhrase = "This is a test of the selected voice."
                val utteranceId = "test_${UUID.randomUUID()}"
                
                Log.d("TTS", "Preparing to speak test phrase")
                
                // Store current state
                val currentTtsEnabled = isTtsEnabled.value
                val wasSpeaking = isSpeaking
                
                // Temporarily disable TTS to prevent new messages from being added during test
                isTtsEnabled.value = false
                
                // Stop any current speech
                textToSpeech?.stop()
                
                // Reset speaking state
                isSpeaking = false
                
                // Store current queue contents temporarily if needed
                val queueContents = if (ttsQueue.isNotEmpty()) ArrayList(ttsQueue) else null
                
                // Clear the TTS queue to ensure test phrase plays immediately
                ttsQueue.clear()
                updateQueueSize()
                
                // Abandon previous audio focus
                abandonAudioFocus()
                delay(100) // Longer delay to allow audio focus release
                
                // Get fresh audio focus for the test phrase
                val audioFocusResult = requestAudioFocusAndWait()
                if (audioFocusResult == AudioManager.AUDIOFOCUS_REQUEST_FAILED) {
                    Log.w("TTS", "Failed to get audio focus for test phrase")
                }
                
                // Mark as speaking for the test phrase
                isSpeaking = true
                
                // Speak the test phrase with QUEUE_FLUSH to interrupt anything currently playing
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    val bundle = Bundle()
                    bundle.putString(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId)
                    val result = textToSpeech?.speak(testPhrase, TextToSpeech.QUEUE_FLUSH, bundle, utteranceId)
                    if (result == TextToSpeech.ERROR) {
                        Log.e("TTS", "Error speaking test phrase")
                        isSpeaking = false
                    }
                } else {
                    @Suppress("DEPRECATION")
                    val params = HashMap<String, String>()
                    params[TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID] = utteranceId
                    val result = textToSpeech?.speak(testPhrase, TextToSpeech.QUEUE_FLUSH, params)
                    if (result == TextToSpeech.ERROR) {
                        Log.e("TTS", "Error speaking test phrase")
                        isSpeaking = false
                    }
                }
                
                Log.d("TTS", "Speaking test phrase with voice: ${selectedVoice.value?.name}")
                
                // We'll wait for the test phrase to finish
                // The utterance listener should handle the onDone event for test phrases
                // but as a fallback, we use a delay and manual restoration
                
                // Wait for 3 seconds to make sure the test phrase has time to complete
                // This is a fallback in case the utterance callbacks aren't properly received
                delay(3000)
                
                // Reset state after test phrase
                if (isSpeaking) {
                    Log.d("TTS", "Test phrase didn't complete via callbacks, manually resetting state")
                    textToSpeech?.stop()
                    isSpeaking = false
                    abandonAudioFocus()
                }
                
                // Restore queue if needed
                if (queueContents != null && queueContents.isNotEmpty()) {
                    ttsQueue.addAll(queueContents)
                    updateQueueSize()
                    Log.d("TTS", "Restored ${queueContents.size} messages to queue after test")
                }
                
                // Restore TTS enabled state
                isTtsEnabled.value = currentTtsEnabled
                
                // Resume processing if we were speaking before
                if (currentTtsEnabled && !isSpeaking && ttsQueue.isNotEmpty()) {
                    delay(200) // Longer delay for stability
                    processNextTtsItem()
                }
            } catch (e: Exception) {
                Log.e("TTS", "Error speaking test phrase", e)
                isSpeaking = false
                
                // Make sure we re-enable TTS if it was enabled before the error
                if (!isTtsEnabled.value) {
                    isTtsEnabled.value = true
                }
            }
        }
    }
    
    // Skip current message and move to the next
    fun skipCurrentMessage() {
        if (isSpeaking) {
            try {
                Log.d("TTS", "Skipping current message")
                
                // Stop the current speech
                textToSpeech?.stop()
                
                // Reset speaking state to allow next message to play
                isSpeaking = false
                
                // Add a small delay to ensure TTS engine has time to process the stop command
                // and release any resources
                viewModelScope.launch {
                    delay(300)
                    
                    // Check if we have more messages to process
                    if (ttsQueue.isNotEmpty()) {
                        Log.d("TTS", "Starting next message after skip")
                        processNextTtsItem()
                    } else {
                        // No more messages, so release audio focus
                        abandonAudioFocus()
                    }
                }
            } catch (e: Exception) {
                Log.e("TTS", "Error skipping current message", e)
                isSpeaking = false
                processNextTtsItem()
            }
        }
    }
    
    // Clear the TTS queue
    fun clearTtsQueue() {
        try {
            Log.d("TTS", "Clearing TTS queue, size before clear: ${ttsQueue.size}")
            
            // Clear our queue
            ttsQueue.clear()
            updateQueueSize()
            
            // Stop any current speech
            if (isSpeaking) {
                textToSpeech?.stop()
                isSpeaking = false
            }
            
            // The actual queue in the TTS engine might still have pending items
            // Make sure we flush the internal TTS queue as well if possible
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                textToSpeech?.let {
                    try {
                        val result = it.stop()
                        if (result != TextToSpeech.SUCCESS) {
                            Log.w("TTS", "Failed to stop TTS engine properly, result: $result")
                        } else {
                            Log.d("TTS", "Successfully stopped TTS engine")
                        }
                    } catch (e: Exception) {
                        Log.e("TTS", "Error stopping TTS engine", e)
                    }
                }
            }
            
            // Release audio focus since we're not speaking anymore
            abandonAudioFocus()
            
            Log.d("TTS", "TTS queue cleared")
        } catch (e: Exception) {
            Log.e("TTS", "Error clearing TTS queue", e)
        }
    }
    
    /**
     * Check if TTS is available on the device
     * This can help ensure we have a working TTS engine
     */
    fun checkTtsAvailability(context: Context) {
        try {
            // Check if TTS data is present
            val intent = Intent()
            intent.action = TextToSpeech.Engine.ACTION_CHECK_TTS_DATA
            
            // Use context.startActivity for API below 23 to avoid permission issues
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                context.startActivity(intent)
            }
            
            // Log supported languages and voices
            textToSpeech?.let { tts ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    val voices = tts.voices
                    if (voices != null && voices.isNotEmpty()) {
                        Log.d("TTS", "Available voices: ${voices.size}")
                        
                        // Log first 5 voices for debugging
                        voices.take(5).forEach { voice ->
                            Log.d("TTS", "Voice: ${voice.name}, Locale: ${voice.locale}, " +
                                    "Quality: ${if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) voice.quality else "unknown"}")
                        }
                    } else {
                        Log.w("TTS", "No voices found")
                    }
                    
                    // Log current voice
                    Log.d("TTS", "Current voice: ${tts.voice?.name ?: "Default"}")
                }
                
                // Log language availability
                val isLanguageAvailable = tts.isLanguageAvailable(Locale.US)
                Log.d("TTS", "US Language availability: $isLanguageAvailable")
                val availableLocales = Locale.getAvailableLocales()
                    .filter { tts.isLanguageAvailable(it) == TextToSpeech.LANG_AVAILABLE || 
                              tts.isLanguageAvailable(it) == TextToSpeech.LANG_COUNTRY_AVAILABLE ||
                              tts.isLanguageAvailable(it) == TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE }
                    .take(5)
                Log.d("TTS", "Sample available locales: ${availableLocales.joinToString { it.displayName }}")
            }
        } catch (e: Exception) {
            Log.e("TTS", "Error checking TTS availability", e)
        }
    }
    
    // Connect to Twitch chat - no login required
    fun connectToTwitchChat() {
        if (channelName.value.isNotBlank()) {
            // Cancel existing job if any
            chatJob?.cancel()
            
            // Clear previous messages when connecting to a new channel
            _chatMessages.clear()
            
            // Start new connection
            chatJob = viewModelScope.launch {
                try {
                    isConnected.value = true
                    
                    // Use our custom chat service instead of Twitch4J
                    val result = chatService.connectToChat(channelName.value) { message ->
                        viewModelScope.launch(Dispatchers.Main) {
                            // Increment message counter
                            messageCount.incrementAndGet()
                            
                            _chatMessages.add(0, message)
                            // Limit the chat history size
                            if (_chatMessages.size > maxChatHistorySize.value) {
                                _chatMessages.removeAt(_chatMessages.lastIndex)
                            }
                            
                            // Add to TTS queue if enabled and not exceeding max queue size
                            if (isTtsEnabled.value) {
                                val ttsText = "${message.username} says: ${message.message}"
                                if (ttsQueue.size < maxTtsQueueSize.value) {
                                    // Add to the queue
                                    ttsQueue.add(ttsText)
                                    updateQueueSize()
                                    
                                    Log.d("TTS", "Added message to queue: ${message.username}, queue size: ${ttsQueue.size}")
                                    
                                    // Only start processing if we're not already speaking
                                    if (!isSpeaking) {
                                        processNextTtsItem()
                                    }
                                } else {
                                    Log.d("TTS", "Queue full, skipping message from: ${message.username}")
                                }
                            }
                        }
                    }
                    
                    if (!result) {
                        isConnected.value = false
                    }
                    
                } catch (e: Exception) {
                    Log.e("TwitchChat", "Error connecting to Twitch chat", e)
                    isConnected.value = false
                }
            }
        }
    }
    
    fun disconnectFromTwitchChat() {
        chatJob?.cancel()
        chatJob = null
        chatService.disconnect()
        isConnected.value = false
    }
    
    fun toggleTts() {
        isTtsEnabled.value = !isTtsEnabled.value
        if (isTtsEnabled.value && ttsQueue.isNotEmpty() && !isSpeaking) {
            processNextTtsItem()
        }
    }
    
    fun clearChat() {
        _chatMessages.clear()
    }
    
    override fun onCleared() {
        super.onCleared()
        
        try {
            // Stop any current speech immediately
            textToSpeech?.stop()
            
            // Properly abandon audio focus synchronously before async operations
            abandonAudioFocus()
            
            // Cancel all running jobs
            viewModelScope.launch {
                // Disconnect from Twitch chat
                disconnectFromTwitchChat()
                
                // Cancel memory check job
                memoryCheckJob?.cancel()
                
                // Clear TTS queue
                ttsQueue.clear()
                updateQueueSize()
                
                // Make sure speech is stopped
                isSpeaking = false
                
                // Clear audio focus resources
                audioFocusRequest = null
                audioManager = null
            }
            
            // Proper cleanup of TextToSpeech resources - do this synchronously
            cleanupTts()
            
            // Force garbage collection suggestion
            System.gc()
            
        } catch (e: Exception) {
            Log.e("TwitchChatViewModel", "Error during cleanup", e)
        }
    }
}
